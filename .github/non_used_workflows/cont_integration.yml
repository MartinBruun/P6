name: CI Pipeline

on:
  pull_request:

env:
  WEB_MIN_COVERAGE: 75
  BOX_MIN_COVERAGE: 43
  APP_MIN_COVERAGE: "Last set to 13, but don't know how to inject as environment variable"

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-java@v1 # For App
      with:
        java-version: '8.x'
    
    # Setup the flutter environment.
    - uses: subosito/flutter-action@v1
      with:
        channel: 'stable' # 'dev', 'alpha', or 'stable' default to: 'stable'
        flutter-version: '2.10.5' # set to the flutter version of MartinBruun due to previous errors

    - name: (Build) Build all
      run: |
        docker-compose up -d --build

    - name: (Web CI) Check for linting before running tests
      uses: py-actions/flake8@v2
      with:
          path: "washee_web"
          max-line-length: 9000

    - name: (Web CI) Run Tests
      working-directory: ./washee_web
      run: |
        docker-compose exec -T web pytest --cov=. --cov-fail-under=$WEB_MIN_COVERAGE

    - name: (Box CI) Check for linting before running tests
      uses: py-actions/flake8@v2
      with:
        path: "washee_box"
        max-line-length: 9000

    - name: (Box CI) Run Tests
      run: |
        docker-compose exec -T box python3 -m pytest --cov=. --cov-fail-under=$BOX_MIN_COVERAGE

    - name: (App CI) Setup necessary environment files
      working-directory: ./washee_app
      run: |
        echo "WEB_API_HOST=http://localhost:8000" > .env.dev
        echo "BOX_API_HOST=http://localhost:8001" >> .env.dev
        echo "BOX_WIFI_SSID=boxNetworkName" >> .env.dev
        echo "BOX_WIFI_PASSWORD=boxNetworkPassword" >> .env.dev
        echo "BOX_HAS_INTERNET=true" >> .env.dev
        echo "Necessary production environment to satisfy flutter assets" > .env.prod

    - name: (App CI) Lint according to analysis_options.yaml rules
      working-directory: ./washee_app
      run: |
        flutter analyze

    - name: (App CI) Run flutter tests and check for minimum coverage afterwards
      working-directory: ./washee_app
      run: |
        flutter clean
        flutter pub get
        flutter test --coverage

    - uses: VGVentures/very-good-coverage@v1.1.1
      with:
        path: "./washee_app/coverage/lcov.info"
        min_coverage: 13
        exclude: "**/*_observer.dart **/change.dart"


    # Tests above should be run as a "Quick Feedback" commit tests, running max for 5 minutes
    # These tests should build and run on the development software
    # Tests below here should be a seperate job that runs given the previous tests pass
    # These tests should build and run on the production software
    # For all tests, they should run on a specified .env.test environment, which simulate production
    # When these tests are done, and the merge completed, the code should get loaded up to a staging server
    # The staging server should have its own .env.stage environment

    - name: (App Int) Start an Android Emulator and Run Integration Tests
      uses: reactivecircus/android-emulator-runner@v2
      with:
        api-level: 29
        profile: pixel
        script: ./scripts/app/integration_test.sh

    # INCLUDE MORE TESTS! Ie. include enough tests, so that it is certain that it is releasable (Continious Delivery goal)
    # The test server running the pipeline should simulate a production server, for proper Communication Testing
    # This can include: 
      # Acceptance (testing user stories, ie. app integration tests trying to simulate a user), 
      # Penetration, (testing abuse stories, ie. app integration tests trying to simulate a hacker),
      # Static Linting (testing architechture constraints are upheld, taint analysis for user input, etc.)
      # Communication (testing high level protocols between the applications, ie. http(s), CSRF, Cors, etc. )
      # Performance (testing performance criteria for System and Critical Components)

    # It should also automatically deploy to a staging server (including a "Testers App") after merge (in a seperate yaml file)
    # The staging server should function as "the place where test users get the newest features and rapport the newest bugs"
    # With a press of a button, the changes on staging should be deployable to production
    
    - name: (Done) Tear down
      run: |
        docker-compose down -v